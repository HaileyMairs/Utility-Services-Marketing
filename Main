'''11/12/25
Automatically builds the gui'''

import tkinter as tk
from tkinter import ttk, messagebox
import inspect
import importlib

# -------------------- CONFIG --------------------
BG_BLACK = "#000000"
CREAM = "#FFF8E1"
DARK_GREEN = "#0b5d3b"
PANEL_BG = "#0f0f0f"
TEXT_COLOR = CREAM

# Add all parent-level modules here (like Alarms, DeviceHealth, etc.)
IMPORT_MODULES = ["Alarms"]  # you can extend this list, e.g. ["Alarms", "DeviceHealth"]
# -------------------------------------------------


class UtilityGUI(tk.Tk):
    def __init__(self, app):
        super().__init__()
        self.app = app
        self.title("Dynamic Utility GUI")
        self.state('zoomed')
        self.configure(bg=BG_BLACK)

        self._setup_styles()
        self._create_sidebar()
        self._create_main_panel()

    def _setup_styles(self):
        s = ttk.Style(self)
        s.theme_use('clam')

        s.configure("TFrame", background=BG_BLACK)
        s.configure("Left.TFrame", background=PANEL_BG)
        s.configure("Main.TFrame", background=BG_BLACK)
        s.configure("TLabel", background=BG_BLACK, foreground=TEXT_COLOR)
        s.configure("Accent.TButton", background=DARK_GREEN, foreground=CREAM)
        s.map("Accent.TButton", background=[('active', DARK_GREEN)], foreground=[('active', CREAM)])

        s.configure("Treeview",
                    background=BG_BLACK,
                    foreground=CREAM,
                    fieldbackground=BG_BLACK,
                    rowheight=28,
                    font=("Segoe UI", 10))
        s.configure("Treeview.Heading",
                    background=DARK_GREEN,
                    foreground=CREAM,
                    font=("Segoe UI", 10, "bold"))
        s.map("Treeview.Heading",
              background=[('active', '#1a7b50')],
              foreground=[('active', CREAM)])

    def _create_sidebar(self):
        self.sidebar = ttk.Frame(self, style="Left.TFrame", width=220)
        self.sidebar.pack(side="left", fill="y")
        self.sidebar.pack_propagate(False)

        tk.Label(self.sidebar, text="Menu", font=("Segoe UI", 14, "bold"),
                 bg=PANEL_BG, fg=CREAM).pack(pady=(16, 8))

        # Auto-build buttons
        for parent_class, subclasses in self.app.utility_classes.items():
            self._create_menu_group(parent_class, subclasses)

    def _create_menu_group(self, parent_class, subclasses):
        """Create a collapsible menu group for each parent class."""
        name = getattr(parent_class, "__doc__", None) or parent_class.__name__
        visible = tk.BooleanVar(value=False)

        # Main button
        button = ttk.Button(self.sidebar, text=f"{name} ▸", style="Accent.TButton")
        button.pack(fill="x", padx=12, pady=(6, 0))

        container = tk.Frame(self.sidebar, bg=PANEL_BG)
        container.pack(fill="x", padx=0, pady=0)
        frame = tk.Frame(container, bg=PANEL_BG)
        frame.pack_forget()

        def toggle():
            if visible.get():
                frame.pack_forget()
                button.config(text=f"{name} ▸")
            else:
                frame.pack(fill="x", padx=24)
                button.config(text=f"{name} ▾")
            visible.set(not visible.get())

        button.config(command=toggle)

        # Submenu buttons
        for subclass in subclasses:
            label = getattr(subclass, "__doc__", None) or subclass.__name__
            tk.Button(frame, text=label, bg=PANEL_BG, fg=CREAM,
                      relief="flat", anchor="w",
                      command=lambda p=parent_class, s=subclass: self.app.run_utility(p, s)
                      ).pack(fill="x", pady=2)

    def _create_main_panel(self):
        self.main_frame = ttk.Frame(self, style="Main.TFrame")
        self.main_frame.pack(side="left", fill="both", expand=True, padx=8, pady=8)

        self.title_label = tk.Label(
            self.main_frame, text="", font=("Segoe UI", 18, "bold"),
            bg=BG_BLACK, fg=CREAM, anchor="w"
        )
        self.title_label.pack(fill="x", pady=(0, 5))

        table_frame = ttk.Frame(self.main_frame, style="Main.TFrame")
        table_frame.pack(fill="both", expand=True)

        self.tree = ttk.Treeview(table_frame, columns=(), show="headings")
        self.tree.pack(side="left", fill="both", expand=True)

        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        scrollbar.pack(side="right", fill="y")
        self.tree.configure(yscrollcommand=scrollbar.set)


class UtilityApp:
    def __init__(self):
        self.utility_classes = self._discover_utilities()
        self.gui = UtilityGUI(self)

    def _discover_utilities(self):
        """Dynamically discover parent and subclass structure from imported modules."""
        utilities = {}
        for module_name in IMPORT_MODULES:
            try:
                mod = importlib.import_module(module_name)
            except ImportError as e:
                messagebox.showerror("Import Error", f"Failed to import {module_name}: {e}")
                continue

            for name, obj in inspect.getmembers(mod, inspect.isclass):
                # Only consider top-level classes defined in the module (not external)
                if obj.__module__ == mod.__name__:
                    # Find subclasses inside
                    subclasses = [
                        sub for subname, sub in inspect.getmembers(obj, inspect.isclass)
                        if sub.__module__ == mod.__name__
                    ]
                    utilities[obj] = subclasses
        return utilities

    def run_utility(self, parent_class, subclass):
        """Run the .run() method of a subclass and display the output."""
        label = f"{getattr(parent_class, '__doc__', parent_class.__name__)} - " \
                f"{getattr(subclass, '__doc__', subclass.__name__)}"
        self.gui.title_label.config(text=label)

        try:
            instance = subclass()
            if not hasattr(instance, "run"):
                raise AttributeError(f"{subclass.__name__} has no run() method.")
            rows = instance.run()
        except Exception as e:
            messagebox.showerror("Execution Error", str(e))
            return

        # Determine columns automatically
        if not rows:
            cols = ("Message",)
            rows = [["⚠️ No data found."]]
        elif isinstance(rows[0], (list, tuple)):
            cols = [f"Column {i+1}" for i in range(len(rows[0]))]
        else:
            cols = ("Result",)
            rows = [[r] for r in rows]

        self._populate_tree(rows, cols)

    def _populate_tree(self, rows, cols):
        tree = self.gui.tree
        tree.delete(*tree.get_children())
        tree["columns"] = cols
        tree["show"] = "headings"

        for c in cols:
            tree.heading(c, text=c, anchor="center")
            tree.column(c, width=150, anchor="center")

        for i, r in enumerate(rows):
            tag = "evenrow" if i % 2 == 0 else "oddrow"
            tree.insert("", "end", values=r, tags=(tag,))

        tree.tag_configure("evenrow", background="#000000", foreground=CREAM)
        tree.tag_configure("oddrow", background="#0f3021", foreground=CREAM)


if __name__ == "__main__":
    app = UtilityApp()
    app.gui.mainloop()
